<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="360" >
    <title>memor.io</title>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Symbols&display=swap');
    </style>
    
    <script src="https://unpkg.com/p5@1.4.0/lib/p5.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
    	body {
    		margin:  0;
        font-family: 'Arial';
    	}
    </style>
	</head>

	<body>
		<script>

const randomPos = () => [ Math.floor( Math.random() * width ), Math.floor( Math.random() * height ) ];
const setRandomPos = ( agent ) => { agent.x = randomPos()[0]; agent.y = randomPos()[1]; }
const randomB16Num = ( digits ) => Math.floor( Math.random() * Math.pow( 16, digits ) ).toString( 16 );  // generate random base-16 string with input number of digits i.e. 0-f
const randomUnicodeChar = () => { 
  // let c, n, i;
  // let count = 0;
  // do { 
  //   n = Math.floor( Math.random() * 2 ).toString() + randomB16Num( 4 );
  //   i = parseInt( n, 16 );
  //   // i = Math.floor(Math.random() * 20000);
  //   c = String.fromCodePoint( i );
  //   count++;
  // } while ( !hasGlyph(c) );

  // console.log( c.codePointAt(0).toString(16), c );
  // if ( count > 1 ) console.log( 'attempts: %i', count );

  
  const availableIndex = [
    ['0', '1', '2', '3', '4', 'a', 'f'],
    // ['f'],
    ['0', '1', '2', '3', '4', '6', '8', 'b', 'c', 'd', 'e', 'f']
    // [ '2']
  ]
  const d20fIndex = ['a', 'b', 'c', 'd', 'e', 'f'];

  let c, n;
  let d1, d2, d3, d45;
  do {
    d1 = Math.floor( Math.random() * 2 ); // 0 or 1, but higher chance on 0;
    //  d1 = 0;
    d2 = availableIndex[ d1 ][ Math.floor( Math.random() * availableIndex[ d1 ].length ) ];
    //  d345 = randomB16Num( 3 );
    if ( d1 == 0 ) {
    d3 = d20fIndex[ Math.floor( Math.random() * d20fIndex.length ) ];
    } else {
      d3 = 0;
    }
     d45 = randomB16Num( 2 );

    n = parseInt( (d1 + d2 + d3 + d45), 16 );
    c = String.fromCodePoint( n );
  } while (!hasGlyph(c));

  // console.log( hasGlyph( c ));
  console.log( 'd: %s%s%s%s, c: %s', d1, d2, d3, d45, c);

  return c;
  }

// The following is taken from: https://stackoverflow.com/questions/1911000/detecting-individual-unicode-character-support-with-javascript

/**
 * The first argument is the character you want to test, and the second argument is the font you want to test it in.
 * If the second argument is left out, it defaults to the font of the <body> element.
 * The third argument isn't used under normal circumstances, it's just used internally to avoid infinite recursion.
 * */
function hasGlyph(character, font = getComputedStyle(document.body).fontFamily, recursion = false){
    //Create the canvases
    // document.createElement("canvas");
    let testCanvas = document.createElement("canvas");
    let refCanvas = document.createElement("canvas");
    testCanvas.width = refCanvas.width = testCanvas.height = refCanvas.height = 150;

    //Render the characters
    let testContext = testCanvas.getContext("2d");
    let refContext = refCanvas.getContext("2d");
    testContext.font = refContext.font = "100px " + font;
    testContext.fillStyle = refContext.fillStyle = "black";
    testContext.fillText(character, 0, 100);
    refContext.fillText('\uffff', 0, 100);
    
    //Firefox renders unsupported characters by placing their character code inside the rectangle making each unsupported character look different.
    //As a workaround, in Firefox, we hide the inside of the character by placing a black rectangle on top of it.
    //The rectangle we use to hide the inside has an offset of 10px so it can still see part of the character, reducing the risk of false positives.
    //We check for Firefox and browers that behave similarly by checking if U+FFFE is supported, since U+FFFE is, just like U+FFFF, guaranteed not to be supported.
    if(!recursion && hasGlyph('\ufffe', font, true)){
        testContext.fillStyle = refContext.fillStyle = "black";
        testContext.fillRect(10, 10, 80, 80);
        refContext.fillRect(10, 10, 80, 80);
    }

    //Check if the canvases are identical
    return testCanvas.toDataURL() != refCanvas.toDataURL();
}


const decoder = new TextDecoder("utf-8");

const id = randomB16Num( 4 );  // generate random base-16 4-digit code as id i.e. 1-f
const char = randomUnicodeChar();
console.log( char );
const color = randomB16Num( 6 );

const thisAgent = {
  	id: id,
  	char: char,
  	color: color,
  	x: 200,
  	y: 200
  }




// const memory = [ thisAgent ];   // memory includes all agents that are attached.
const world  = [ thisAgent ];   // world includes all agents that are connected.

const agentSize = 40;

const clientId = "memorio-" + id;

const bg = "#fff";

let textX = 100;
let textY = 100;
const lineHeight = 30;
let font;

let v1, v2;
let speed = 2;

// MQTT --------------------
const server = "wss://datt3700:datt3700experiments@datt3700.cloud.shiftr.io";
const client = mqtt.connect(server, {
  clientId: clientId,
  will: {
    topic: '/memorio/disconnect',
    payload: JSON.stringify( thisAgent ),
    QoS: 1,
    retain: false
  }
});

// Functions ++++++++++++++++++++++++++++++

// function preload() {

//   font = loadFont('https://fonts.googleapis.com/css2?family=Noto+Sans+Symbols:wght@100&display=swap');
//   console.log(font);

// }

function setup() {

  createCanvas( windowWidth, windowHeight );

  background( bg );

  // setRandomPos( thisAgent );
  
  client.on('connect', () => client.subscribe('/memorio/*') );
  client.on('message', (topic, message) => messageReceived(topic, message) );
  client.publish( "memorio/connect", JSON.stringify( thisAgent ) );

  fill('white');
  noStroke();

  v1 = createVector();
  v2 = createVector();
  
  // const noto = loadFont('../assets/noto.ttf');
  // textFont( noto );
  textFont( 'Arial' );

}

function draw() { 

  background( 255 ,20);

  drawEdges();
  drawTitle();

  if ( mouseIsPressed ) move(); 
  
  textSize( agentSize );
  for ( a of world ) drawAgent( a );

}

function drawEdges() {
  fill( 235, 20 );
  rect( 0, 0, width / 3, height );
  rect( 0, 0, width, height / 3 );
  rect( width - ( width / 3 ), 0, width / 3, height );
  rect( 0, height - ( height / 3 ), width, height / 3 );
}

function drawTitle() {

  textSize( 24 );
  fill( 50 );
  textStyle( BOLD );
  text( 'Memor.io', 50, 50 );
  textStyle( NORMAL );
  fill( 100 );
  text( 'Press arrow keys/WASD', 50, 100 );
  text( 'or click on edges to move.', 50, 150 );

}

function drawAgent( agent ) {

  fill( "#" + agent.color );
  text( agent.char, agent.x, agent.y, agentSize )

}

let timer = 0;

function move() {

  v1.set( thisAgent.x, thisAgent.y );
  v2.set( mouseX, mouseY );

  v1.add( v2.sub( v1 ).setMag( speed ) );

  thisAgent.x = v1.x;
  thisAgent.y = v1.y;

  timer++;

  if ( timer % 5 == 0 )  client.publish( "/memorio/agent", JSON.stringify( thisAgent ) ); // limit

}

// const updateThisAgent = () => world[0] = thisAgent;

function keyPressed() {

  // thisAgent.char += 1;

  switch ( keyCode ) {

    case ( 37 ):
    case ( 65 ):
      thisAgent.x -= agentSize;
      break;

    case ( 38 ):
    case ( 87 ):
      thisAgent.y -= agentSize;
      break;
    
    case ( 39 ):
    case ( 68 ):
      thisAgent.x += agentSize;
      break;
    
    case ( 40 ):
    case ( 83 ):
      thisAgent.y += agentSize;
      break;

    case( 32 ):
      thisAgent.char = randomUnicodeChar();
      thisAgent.color = randomB16Num( 6 );

  }

  // updateThisAgent();

  client.publish( "/memorio/agent", JSON.stringify( thisAgent ) );

}

function mouseClicked() {

  let mouse = [ mouseX, mouseY ];

  console.log()

  if ( mouse[0] < width / 3 ) thisAgent.x -= agentSize;

  if ( mouse[1] < height / 3 ) thisAgent.y -= agentSize;

  if ( mouse[0] > width - ( width / 3 ) ) thisAgent.x += agentSize;

  if ( mouse[1] > height - ( height / 3 ) ) thisAgent.y += agentSize;


}

function messageReceived(topic, message) {

  topic = topic.split( '/' )[2];      // get the first sub branch of memorio.
  message = decoder.decode(message);  // decode array buffer.

  let agent = JSON.parse( message );    
  
  if ( agent.id == thisAgent.id ) return;  // if the received agent matches this agent, don't do anything.


  switch (topic) {

    case ( 'connect' ):
      world.push( agent );
      client.publish( '/memorio/world', JSON.stringify( thisAgent ) );
      console.log( 'new connection! world = ', world );
      break;

    case ( 'agent' ):
      let a = world.find( a => a.id == agent.id );
      if ( a ) {                // Tried other methods to make a deep copy (JSON.parse/stringify), but this works best.
        a.char = agent.char;
        a.color = agent.color;
        a.x = agent.x;
        a.y = agent.y;
      }
      console.log( "id: %s, char: %s, x: %i, y: %i", agent.id, agent.char, agent.x, agent.y );    // formats like printf
      break;

    case ( 'world' ):
      if ( !world.find( a => a.id == agent.id ) ) world.push( agent );
      console.log( 'received agent. new world = ', world );
      break;

    case ( 'disconnect' ):
      let index = world.findIndex( a => a.id == agent.id );
      if ( index > -1 ) world.splice( index, 1 );
      console.log( 'someone disconnected! new owrld = ', world);
      break;

    case ( 'chat' ):
      console.log( message );
      break;

  }

}

	</script>
</body>