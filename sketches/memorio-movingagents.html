<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="360" >
    <title>memor.io</title>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Symbols&display=swap');
    </style>
    
    <script src="https://unpkg.com/p5@1.4.0/lib/p5.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
    	body {
    		margin:  0;
        font-family: 'Courier';
    	}
      #p5 {
      width:  100%;
      touch-action: none;
      }
    </style>
	</head>

	<body>

    <div id='p5'></div>

		<script>

// import Stats from 'https://unpkg.com/three@0.126.0/examples/jsm/libs/stats.module.js';
// const stats = new Stats();

// let canvas;

const randomPos = () => [ Math.floor( Math.random() * width ), Math.floor( Math.random() * height ) ];

const setRandomPos = ( agent ) => { agent.x = randomPos()[0]; agent.y = randomPos()[1]; }

const randomB16Num = ( digits ) => Math.floor( Math.random() * Math.pow( 16, digits ) ).toString( 16 );  // generate random base-16 string with input number of digits i.e. 0-f

const randomUnicodeChar = () => { 

  /********** Even-ish distribution *************/

  let c, n, i;
  let d1, d2, d345;
  let count = 0;
  do { 
    d1 = Math.floor( Math.random() * 2 ).toString();

    /** distributed **/
    d2 = Math.floor( Math.random() * 2 );
    if ( d1 == 1 || d2 == 1 ) d2 = randomB16Num( 1 );
    d3 = Math.floor( Math.random() * 5 );
    if ( d1 == 1 || d2 == 1 || d3 > 1) d3 = randomB16Num( 1 );
    d45 = randomB16Num( 2 );
    n = d1 + d2 + d3 + d45;

    /** random **/
    // n = d1 + randomB16Num( 4 );

    i = parseInt( n, 16 );
    // i = Math.floor(Math.random() * 20000);
    c = String.fromCodePoint( i );
    count++;
  } while ( !hasGlyph(c) || i < 32 );

  // console.log( c.codePointAt(0).toString(16), c );
  if ( count > 1 ) console.log( 'attempts: %i', count );

  // console.log( 'd: %s%s%s%s, c: %s', d1, d2, d3, d45, c);

  /*************** Emojis-ish ******************/

  // let c, n;
  // let d1, d2, d3, d45;
  // do {
  //   d1 = 1;
  //   d2 = 'f';
  //   d3 = randomB16Num( 1 );
  //   d45 = randomB16Num( 2 );

  //   n = parseInt( (d1 + d2 + d3 + d45), 16 );
  //   c = String.fromCodePoint( n );
  // } while (!hasGlyph(c));

  // console.log( hasGlyph( c ));
  // console.log( 'd: %s%s%s%s, c: %s', d1, d2, d3, d45, c);


  /************* Filtered index ***** *********/

  // const availableIndex = [
  //   // ['0', '1', '2', '3', '4', 'a', 'f'],
  //   ['0', '1', '2', '3', '4', 'a', 'f'],
  //   // ['0', '1', '2', '3', '4', '6', '8', 'b', 'c', 'd', 'e', 'f']
  //   [ 'f']
  // ]
  // const d30fIndex = ['a', 'b', 'c', 'd', 'e', 'f'];

  // let c, n;
  // let d1, d2, d3, d45;
  // do {
  //   d1 = Math.floor( Math.random() * 2 ); // 0 or 1, but higher chance on 0;
  //    d1 = 1;
  //   d2 = availableIndex[ d1 ][ Math.floor( Math.random() * availableIndex[ d1 ].length ) ];
  //   //  d345 = randomB16Num( 3 );
  //   // if ( d1 == 0 ) {
  //   // d3 = d30fIndex[ Math.floor( Math.random() * d30fIndex.length ) ];
  //   // } else {
  //   //   d3 = 0;
  //   // }
  //   d3 = randomB16Num( 1 );
  //   d45 = randomB16Num( 2 );

  //   n = parseInt( (d1 + d2 + d3 + d45), 16 );
  //   c = String.fromCodePoint( n );
  // } while (!hasGlyph(c));

  // console.log( hasGlyph( c ));
  // console.log( 'd: %s%s%s%s, c: %s', d1, d2, d3, d45, c);

  return c;
  }

// The following is taken from: https://stackoverflow.com/questions/1911000/detecting-individual-unicode-character-support-with-javascript

/**
 * The first argument is the character you want to test, and the second argument is the font you want to test it in.
 * If the second argument is left out, it defaults to the font of the <body> element.
 * The third argument isn't used under normal circumstances, it's just used internally to avoid infinite recursion.
 * */
function hasGlyph(character, font = getComputedStyle(document.body).fontFamily, recursion = false) {
    //Create the canvases
    // document.createElement("canvas");
    let testCanvas = document.createElement("canvas");
    let refCanvas = document.createElement("canvas");
    testCanvas.width = refCanvas.width = testCanvas.height = refCanvas.height = 150;

    //Render the characters
    let testContext = testCanvas.getContext("2d");
    let refContext = refCanvas.getContext("2d");
    testContext.font = refContext.font = "100px " + font;
    testContext.fillStyle = refContext.fillStyle = "black";
    testContext.fillText(character, 0, 100);
    refContext.fillText('\uffff', 0, 100);
    
    /**
    * Firefox renders unsupported characters by placing their character code inside the rectangle making each unsupported character look different.
    * As a workaround, in Firefox, we hide the inside of the character by placing a black rectangle on top of it.
    * The rectangle we use to hide the inside has an offset of 10px so it can still see part of the character, reducing the risk of false positives.
    * We check for Firefox and browers that behave similarly by checking if U+FFFE is supported, since U+FFFE is, just like U+FFFF, guaranteed not to be supported.
    * */
    if(!recursion && hasGlyph('\ufffe', font, true)){
        testContext.fillStyle = refContext.fillStyle = "black";
        testContext.fillRect(10, 10, 80, 80);
        refContext.fillRect(10, 10, 80, 80);
    }

    //Check if the canvases are identical
    return testCanvas.toDataURL() != refCanvas.toDataURL();
}

const randomPastel = () => {

  const bounds = [0.5, 0.9];

  const offset = 255 * bounds[0];
  const limit  = 255 * bounds[1];
  const range  = limit - offset;

  const r = Math.floor( ( Math.random() * range ) + offset ).toString(16);
  const g = Math.floor( ( Math.random() * range ) + offset ).toString(16);
  const b = Math.floor( ( Math.random() * range ) + offset ).toString(16);

  // const threshold = 0.5;
  // const total = threshold * 255 * 3;

  // const values = [];
  // values.push( Math.floor( Math.random() * threshold ) );
  // values.push( Math.floor( Math.random() * ( threshold - values[0] ) );
  // values.push( threshold - values[0] - values[1] );

  // const r = values.splice( Math.floor( Math.random() * 3 ), 1 ).toString(16);
  // const g = values.splice( Math.floor( Math.random() * 2 ), 1 ).toString(16);
  // const b = values.splice( Math.floor( Math.random() * 1 ), 1 ).toString(16);

  const color = r + g + b;

  return color;
}

const decoder = new TextDecoder("utf-8");

const id = randomB16Num( 4 );  // generate random base-16 4-digit code as id i.e. 1-f
const char = randomUnicodeChar();
const color = randomB16Num( 6 );

const thisAgent = {
  	id: id,
  	char: char,
  	color: color,
  	x: 0,
  	y: 0
  }

// const memory = [ thisAgent ];   // memory includes all agents that are attached.
const world  = [ thisAgent ];   // world includes all agents that are connected.

const AGENT_SIZE = 40;
const AGENT_SIZE_HALF = AGENT_SIZE / 2;

const clientId = "memorio-" + id;

const OUTER_BACKGROUND = "#ccddee";

const MAP_SIZE = 4000;
const MAP_SHAPE = 'CIRCLE' // CIRCLE or RECT
const MAP_RADIUS = MAP_SIZE/2;
const MAP_WIDTH = MAP_SIZE;
const MAP_HEIGHT = MAP_SIZE;
const MAP_CENTER = {
  X: MAP_WIDTH / 2,
  Y: MAP_HEIGHT / 2
}

// const MAP = {
//   SIZE  :2000;
//   SHAPE :'CIRCLE' // CIRCLE or RECT
//   RADIUS: MAP_SIZE;
//   WIDTH : MAP_SIZE;
//   HEIGHT: MAP_SIZE;
//   CENTER: {
//     X: MAP_WIDTH / 2,
//     Y: MAP_HEIGHT / 2
//   }
// }

let v1, v2, thisVel, newVel;
let speed = 2;

let font;

let showFrameRate = false;

// MQTT --------------------
const server = "wss://datt3700:datt3700experiments@datt3700.cloud.shiftr.io";
const client = mqtt.connect(server, {
  clientId: clientId,
  will: {
    topic: '/memorio/disconnect',
    payload: JSON.stringify( thisAgent ),
    QoS: 1,
    retain: false
  }
});

// Functions ++++++++++++++++++++++++++++++

// function preload() {

//   font = loadFont('https://fonts.googleapis.com/css2?family=Noto+Sans+Symbols:wght@100&display=swap');
//   console.log(font);

// }

function setup() {

  // const container = document.createElement( 'div' );
  // container.setAttribute("id", "container");

  // document.body.appendChild( container );

  // container.appendChild( stats.dom );
  // container.appendChild( canvas );
  
  const canvas = createCanvas( windowWidth, windowHeight, P2D );
  canvas.parent('#p5');
  
  client.on('connect', () => client.subscribe('/memorio/*') );
  client.on('message', (topic, message) => messageReceived(topic, message) );
  client.publish( "memorio/connect", JSON.stringify( thisAgent ) );
  updateStep( messageFreq );

  // scale( 2000 / Math.min( width, height ) );

  v1      = createVector();
  v2      = createVector();
  thisVel = createVector();
  newVel  = createVector();
  pos     = createVector()
  maxMag  = createVector( 0, MAP_RADIUS ).mag();
  
  thisAgent.x = MAP_WIDTH / 2;
  thisAgent.y = MAP_HEIGHT / 2;

  // const noto = loadFont('../assets/noto.ttf');
  // textFont( noto );
  textFont( getComputedStyle(document.body).fontFamily );

}

function draw() { 

  background( OUTER_BACKGROUND );
  
  translate( width / 2, height / 2 );
  translate( -thisAgent.x, -thisAgent.y );

  drawMap();
  // drawEdges();
  drawTitle();
  if ( showFrameRate ) drawFrameRate();

  // if ( mouseIsPressed )
  traverse( ); 
  
  textSize( AGENT_SIZE );
  for ( a of world ) drawAgent( a );



}

// function mou

function drawMap() {

  fill( 255 );
  if ( MAP_SHAPE == 'RECT' )   rect( 0, 0, MAP_WIDTH, MAP_HEIGHT );
  else if ( MAP_SHAPE == 'CIRCLE' ) circle( MAP_CENTER.X, MAP_CENTER.X, MAP_SIZE);

  const mapStep = MAP_SIZE / 20;
  stroke( OUTER_BACKGROUND );
  strokeWeight( 10 );

  for ( let y = 0; y <= MAP_HEIGHT ; y += mapStep ) {
    for ( let x = 0; x <= MAP_WIDTH ; x += mapStep ) {

      point( x, y );

    }
  }
}

function drawEdges() {
  noStroke();
  fill( 235, 20 );
  rect( 0, 0, width / 3, height );
  rect( 0, 0, width, height / 3 );
  rect( width - ( width / 3 ), 0, width / 3, height );
  rect( 0, height - ( height / 3 ), width, height / 3 );
}

function drawTitle() {

  const leftOffset = 150;
  let topOffset = 250;
  const lineHeight = 50;

  noStroke();
  textSize( 24 );
  
  fill( 50 );
  textStyle( BOLD );
  text( 'Memor.io', MAP_CENTER.X - leftOffset, MAP_CENTER.Y - topOffset );
  topOffset -= lineHeight;

  fill( 100 );
  textStyle( NORMAL );
  text( 'Find friends', MAP_CENTER.X - leftOffset, MAP_CENTER.X - topOffset );
  topOffset -= lineHeight;
  text( 'and share your memories.', MAP_CENTER.X - leftOffset, MAP_CENTER.X - topOffset );

}

let fr = "";

function drawFrameRate() {

  if( frameCount % 20 == 0 ) fr = frameRate().toFixed(0).toString() + ' fps';

  noStroke();
  textSize( 18 );
  fill( 100 );

  text( fr, thisAgent.x + 50, thisAgent.y);

}

function drawAgent( agent ) {

  fill( "#" + agent.color );
  text( agent.char, agent.x - AGENT_SIZE_HALF, agent.y - AGENT_SIZE_HALF, AGENT_SIZE ); // drawn with coordinates in the center of character

}

let timer = 0;

function move() {

  v1.set( thisAgent.x, thisAgent.y );
  v2.set( mouseX, mouseY );

  v1.add( v2.sub( v1 ).setMag( speed ) );

  thisAgent.x = v1.x;
  thisAgent.y = v1.y;

  timer++;

   // limit

}

let enableMouse = false;
let messageFreq = 10;   // messages per second given 60fps
let messageStep = 0;
const velThreshold = 0.01;

function updateStep( freq ) { messageStep = 60 / freq; }

let maxMag, pos;

function traverse() {

  if ( !enableMouse ) { newVel.set( 0, 0 ); } // lock movement before first click or if no touch.
  else { newVel.set( ( mouseX - width/2 ) / width, ( mouseY - height/2 ) / height ); }
  newVel.mult( 10 );
  thisVel.lerp(newVel, 0.05);   // lower lerp amount, softer acceleration. 
  thisAgent.x += thisVel.x;
  thisAgent.y += thisVel.y;

  if ( MAP_SHAPE == 'RECT') {

    if ( thisAgent.x <= 0 )           thisAgent.x = 0;
    if ( thisAgent.x >= MAP_WIDTH )   thisAgent.x = MAP_WIDTH;
    if ( thisAgent.y <= 0 )           thisAgent.y = 0;
    if ( thisAgent.y >= MAP_HEIGHT )  thisAgent.y = MAP_HEIGHT;

  } else if (MAP_SHAPE == 'CIRCLE') {

      pos.set( thisAgent.x - MAP_CENTER.X, thisAgent.y - MAP_CENTER.Y );
      pos.limit( maxMag - AGENT_SIZE );

      thisAgent.x = pos.x + MAP_CENTER.X;
      thisAgent.y = pos.y + MAP_CENTER.Y;

  }

  if (
    frameCount % messageStep == 0
    && ( thisVel.x > velThreshold || thisVel.y > velThreshold )
    )
    client.publish( "/memorio/update", JSON.stringify( thisAgent ) );


}

function keyPressed() {

  console.log( keyCode );

  switch ( keyCode ) {

    case ( 37 ):
    case ( 65 ):
      thisAgent.x -= AGENT_SIZE;
      break;

    case ( 38 ):
    case ( 87 ):
      thisAgent.y -= AGENT_SIZE;
      break;
    
    case ( 39 ):
    case ( 68 ):
      thisAgent.x += AGENT_SIZE;
      break;
    
    case ( 40 ):
    case ( 83 ):
      thisAgent.y += AGENT_SIZE;
      break;

    case ( 32 ):
      thisAgent.char = randomUnicodeChar();
      thisAgent.color = randomPastel( );
      break;

    case ( 70 ):
      showFrameRate = !showFrameRate;

  }

  client.publish( "/memorio/update", JSON.stringify( thisAgent ) );

}

function mousePressed() { if ( !enableMouse ) enableMouse = true; }

function mouseReleased() {}

function touchStarted() {

  enableMouse = true;

}

function touchEnded() {

  enableMouse = false;

}

function mouseClicked() {

  const mousePos = createVector( mouseX, mouseY );
  const centrePos = createVector( width/2, height/2 );

  if ( mousePos.dist( centrePos ) < AGENT_SIZE ) {
    thisAgent.char = randomUnicodeChar();
    thisAgent.color = randomPastel( );
  }

  // console.log( 'x: %i, y: %i', mouseX, mouseY );

  // let mouse = [ mouseX, mouseY ];

  // if ( mouse[0] < width / 3 ) thisAgent.x -= AGENT_SIZE;

  // if ( mouse[1] < height / 3 ) thisAgent.y -= AGENT_SIZE;

  // if ( mouse[0] > width - ( width / 3 ) ) thisAgent.x += AGENT_SIZE;

  // if ( mouse[1] > height - ( height / 3 ) ) thisAgent.y += AGENT_SIZE;


}

function messageReceived(topics, message) {

  topics = topics.split( '/' );
  message = decoder.decode(message);  // decode array buffer.

  const topic  = topics[2];     // get the first sub branch of memorio.     
  
  if ( topic == 'chat' ) { console.log( message ); return; }
  if ( topic == 'limit' ) { updateStep( parseInt( message ) ); return; }

  let agent = JSON.parse( message );    
  
  if ( agent.id == thisAgent.id ) return;  // if the received agent matches this agent, don't do anything.


  switch (topic) {

    case ( 'connect' ):
      world.push( agent );
      client.publish( '/memorio/world', JSON.stringify( thisAgent ) );
      console.log( 'new connection! world = ', world );
      break;

    case ( 'update' ):
      // const subtopic = topics[3]; 
      let a = world.find( a => a.id == agent.id );
      if ( a ) {                // Tried other methods to make a deep copy (JSON.parse/stringify), but this works best.
        a.char = agent.char;
        a.color = agent.color;
        a.x = agent.x;
        a.y = agent.y;
      }
      // console.log( "id: %s, char: %s, x: %i, y: %i", agent.id, agent.char, agent.x, agent.y );    // formats like printf
      break;

    case ( 'world' ):
      if ( !world.find( a => a.id == agent.id ) ) world.push( agent );
      console.log( 'received agent. new world = ', world );
      break;

    case ( 'disconnect' ):
      let index = world.findIndex( a => a.id == agent.id );
      if ( index > -1 ) world.splice( index, 1 );
      console.log( 'someone disconnected! new world = ', world);
      break;

  }

}

	</script>
</body>